# Chapter-2 How To solve Coding problems

## Table of Contents

1. [Module Introduction](#module-introduction)

<br/>

## Module Introduction

At the end of the day, an interview is a way for company to find out can you
solve a problem that company or employer has? Because if you're able to solve
their problems then you're valuable, and you will produce more value to them
then the salary that they're paying you. That is what a technical interview
tries to answer.

We can be smart and strategic about where we apply, and how we apply to
a company and we learned about that in the previous sections; But ere comes the
big challenge, you've got an interview, what do you do? Over the next couple of
sections we're going to tackle this question and get you as prepared as possible
for the _coding interview_; and we're going to get very technical.

Up until now we haven't seen that much code, but we're going to get into nitty
gritty details over the next couple of section. Before we dive into _coding
problems_, _data structures_ and _algorithm_ and all of these fun coding
details, we must first understand this one principle, **_how to solve
problems_**. You see if we know every single algorithm in the world inside and
out you know all the data structure you're the best coder in the world.

Well it doesn't guarantee that you will succeed in a technical interview. This
section is meant to prepare you so that you have the foundation laid out, so
that after this all you need to succeed in the technical interview is the _actual
coding aspects of the questions_. It's not the smartest interviewer that gets
hired, most of the time it's the interviewer that is **_able to answer this
fundamental question_**, will you solve the company's problem?

If you're a genius but you can't talk to people, you don't work well with others
or you write ugly code that people don't understand, or you can't communicate
a solution to a problem then you won't get a job. It's not necessarily about the
solution to a problem, in a coding interview it's about the **thought process**,
and knowing the tradeoffs **_between data structures and algorithm, space and time
complexity_**.

Just like in real life coding, you don't memorize things. You have to _deeply
understand them_, understand the _tradeoffs_. That's what  we're doing here.

I know I'm taking a long time to get my points here, but we're trying to build
the fundamental before we dive in really deep, so we **_understand the why of each
thing_**.

<br/>

![chapter-2-1.gif](./images/gif/chapter-2.1.gif "Module introduction")
<br />

We're building this foundation, by _first_ **_understanding the Big-O_**, which
we did in the previous section; and then **_learning how to solve these
problems_**. In this section I'm going to show you step-by-step what we need to
do to solve problems in a way that companies really like; So that you succeed in
this coding interview. We're going to look at `[x]`some sample coding interviews
from Google and see what they did and what is the ideal process to ace this
interview. So that once we have these foundations we can use _data structure_
and _algorithm_ to solve our problems. Because the interview isn't about your
ability to **_memorize_** _data structure_ and _algorithms_, most people make
that mistake.

An interviewers can detect right away who actually knows these things versus
just memorizing them the week before interview. So how you can ace the coding
interview?

In this section we're going to talk about the technical interviews and how to
succeed in them. I'm going to show you what a successful interview at Google
looks like, and then break everything down step by step as to why you need to
do.

I will also give you a  nice little cheat sheet to summarize everything in this
section so that you can always view it before an interview.

At the end, we're going to solve a coding problem ourselves just like you would
in an interview and analyze different solution to that problem based on what we
have learned up until now. We're going to figure out the best way to solve the
problem, but also analyzing different Big-O solutions when it comes to _space_
and _time_.

By the end of this section, you're going to have a big '_aha_'  moment.
I guarantee it, where we're going to take everything we've learned up until now
into our data structure and algorithm section to really understand the
tradeoffs.


**[â¬† back to top](#table-of-contents)**
<br/>
<br/>
